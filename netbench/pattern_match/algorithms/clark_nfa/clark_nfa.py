###############################################################################
#  clark_nfa.py: Module for PATTERN MATCH
#  Copyright (C) 2010 Brno University of Technology, ANT @ FIT
#  Author(s): Vlastimil Kosar <ikosar@fit.vutbr.cz>
###############################################################################
#
#  LICENSE TERMS
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in
#     the documentation and/or other materials provided with the
#     distribution.
#  3. All advertising materials mentioning features or use of this software
#     or firmware must display the following acknowledgement:
#
#       This product includes software developed by the University of
#       Technology, Faculty of Information Technology, Brno and its
#       contributors.
#
#  4. Neither the name of the Company nor the names of its contributors
#     may be used to endorse or promote products derived from this
#     software without specific prior written permission.
#
#  This software or firmware is provided ``as is'', and any express or implied
#  warranties, including, but not limited to, the implied warranties of
#  merchantability and fitness for a particular purpose are disclaimed.
#  In no event shall the company or contributors be liable for any
#  direct, indirect, incidental, special, exemplary, or consequential
#  damages (including, but not limited to, procurement of substitute
#  goods or services; loss of use, data, or profits; or business
#  interruption) however caused and on any theory of liability, whether
#  in contract, strict liability, or tort (including negligence or
#  otherwise) arising in any way out of the use of this software, even
#  if advised of the possibility of such damage.
#
#  $Id$

# Import general modules
import copy
import re
import math
# Import Netbench modules
from netbench.pattern_match import nfa_data
from netbench.pattern_match import nfa_reductions 
from netbench.pattern_match import b_state
from netbench.pattern_match import sym_char_class
from netbench.pattern_match import sym_char
from netbench.pattern_match import sym_kchar
from netbench.pattern_match import b_symbol
from netbench.pattern_match.pattern_exceptions import COMPUTE_ERROR
from netbench.pattern_match.pattern_exceptions import empty_automaton_exception
from netbench.pattern_match.pattern_exceptions import not_strided_exception
from netbench.pattern_match import aux_func

class clark_nfa(nfa_reductions.nfa_reductions):
    """
        Class implementing Clark NFA. Supports also sharing of char classes if \
        b_Sym_char_class symbols are used and parameter canonical is set to    \
        False.
        
        Based on: 
            C. R. Clark and D. E. Schimmel, "Efficient Reconfigurable Logic    \
            Circuits for Matching Complex Network Intrusion Detection Patterns,\
            " In Proceedings of International Conference on Field Programmable \
            Logic and Applications (FPL), pp. 956-959, 2003.                   
        
            C. R. Clark and D. E. Schimmel, "Scalable Pattern Matching         \
            for High-Speed Networks," In Proceedings of IEEE Symposium on      \
            Field-Programmable Custom Computing Machines (FCCM), pp. 249-257,  \
            2004.                                                              
        
        Generated VHDL code depends on those modules: value_decoder.vhd,       \
        state.vhd and final_bitmap.vhd. Those modules are located in directory \
        vhdl.
        
        Supported symbols for this algorithm are sym_char and sym_char_class   \
        (If canonical constructor parameter is set to False) and sym_kchar if  \
        stride parameter is bigger than 1. When strided automaton is used the  \
        parameter canonical does not effect the construction process.
        
        :param canonical: If True all char classes generated by parser are     \
                          removed. If False char classes generated by parser   \
                          are preserved and method create_char_classes() is    \
                          called to cretate every possible char class. When    \
                          strided automaton is used the parameter canonical    \
                          does not effect the construction process.         
        :type canonical: boolean
        :param stride: Number of characters accepted in one clock cycle.       \
                       Defaults to 1 char per CLK. Only powers of 2 supported.
        :type stride: int
        :param use_bram: Use BRAM to implement character decoder.
        :type use_bram: boolean
    """
    def __init__(self, canonical = True, stride = 1, use_bram = False):
        """
            Class constructor.
        """
        nfa_reductions.nfa_reductions.__init__(self)
        # Set specific setting for strided automaton
        if stride > 1:
            self.width = stride * 8
            self.template = aux_func.getPatternMatchDir() + "/algorithms/clark_nfa/vhdl/clark_strided_nfa.vhd"
        # Set specific setting for clasic automaton
        else:
            self.width = 8
            self.template = aux_func.getPatternMatchDir() + "/algorithms/clark_nfa/vhdl/clark_nfa.vhd"
        # Set stride independent values
        self._statistic = dict()
        self._useBram = use_bram
        self._LUTInputs = 6
        self._luts = 0
        self.canonical = canonical
        self.stride = stride
        
    def compute(self):
        """
            Compute Clark automata mapping into FPGA.
        """

        # Call parent compute
        nfa_reductions.nfa_reductions.compute(self)
        # Check if parent compute is OK
        if not self.get_compute():
            raise COMPUTE_ERROR
        
        # Check if automaton is loaded into object
        if self._automaton.is_empty() == True:
            raise empty_automaton_exception
        
        # Remove epsilon transitions
        self.remove_epsilons()
                
        # Share prefixes
        self.share_prefixes()

        # If strided automaton is requested stride the automaton
        if self.stride > 1:
            # Create char classes
            self.create_char_classes()
            # Compute strided automaton
            stride = 1
            while stride < self.stride:
                self.stride_2()
                stride = stride * 2
        # Otherwise perform operations specific for clasic NFA
        else:
            # Check if canonical (acording to published papers) symbol support 
            # (only chars) is requested.
            if self.canonical == True:
                # Remove char classes
                self.remove_char_classes()
            else:
                # Create char classes
                self.create_char_classes()
        
        # We need to perform the mapping to know number of used FPGA resources
        self.get_HDL()
        # Set compute value to True to indicate that all is computed
        self._compute = True
        
    def  get_HDL(self):
        """
            Return VHDL description of NFA unit implemented in Clark's approach.
                    
            :returns: VHDL description of NFA unit implemented in Clark's      \
                      approach.
            :rtype: string
        """
        # Checks specific for strided automaton
        if self.stride > 1:
            # Check if automaton is strided
            if self._automaton.Flags.has_key("Stride") and self._automaton.Flags["Stride"] > 1:
                self.width = self._automaton.Flags["Stride"] * 8
            else:
                raise not_strided_exception
        
        # Open VHDL template file and load the template
        f = open(self.template, "rb");    #Opens file automat
        blob = f.read()
        tmp = re.split("%\$%", blob)
        
        # Init atributes
        self._brams = 0
        self._luts = 0
        
        # Remove epsilons - TODO: Add check if automaton is epsilon free and 
        # then remove this.
        self.remove_epsilons()
        
        # Get VHDL description of shared character decoder
        chdec = self._get_char_dec_HDL()
        # Get VHDL description of mapped automaton's logic
        logic = self._get_logic_HDL()
        # Get VHDL description of final states
        final = self._get_final_HDL()
        # Concatenate signal description
        dataSignal = chdec[0] + logic[0] + final[0]
        # Concatenate logic description - architecture
        dataImplementation = chdec[1] + logic[1] + final[1]
        
        # Set generated code markers - begin
        textSignal = "-- --------------- GENERATED BY CLARK_NFA.PY ----------------\n"
        textImplementation = "-- --------------- GENERATED BY CLARK_NFA.PY ----------------\n"
        
        # Add signal description to output
        for element in dataSignal:
            textSignal += element
        # Add logic description to output
        for element in dataImplementation:
            textImplementation += element
        
        # Set generated code markers - end
        textSignal += "-- --------------- END ----------------\n"
        textImplementation += "-- --------------- END ----------------\n"
        
        # Add result into loaded VHDL template
        result = tmp[0] + str(self.width) + tmp[1] + str(self._fStateNum) + tmp[2] + textSignal + tmp[3] + textImplementation + tmp[4]
        
        # Return complete VHDL code.
        return result
        
    def _get_char_dec_HDL(self):
        """
            Return HDL description of shared char decoder as 
            (signals, description). 
            
            :returns: HDL description of shared char decoder as                \
                     (signals, description).
            :rtype: tuple(list(string),list(string))
        """
        # Shared character decoders for clasic automaton
        if self.stride == 1:
            if self._useBram == True:
                # Compute BRAM ROM table
                table = [["0" for x in xrange(256)] for y in xrange(len(self._automaton.alphabet))]
                keys = self._automaton.alphabet.keys()
                for i in xrange(len(keys)):
                    if self._automaton.alphabet[keys[i]].get_type() == b_symbol.io_mapper["b_Sym_char_class"]:
                        for char in self._automaton.alphabet[keys[i]].charClass:
                            table[i][ord(char)] = "1"
                    if self._automaton.alphabet[keys[i]].get_type() == b_symbol.io_mapper["b_Sym_char"]:
                        table[i][ord(self._automaton.alphabet[keys[i]].char)] = "1"
                # Generate BRAM ROM table VHDL code
                # List of signal definitions
                signalList = list()
                # list of logic description - architecture
                descriptionList = list()
                cstable = list()
                for i in xrange(256):
                    selement = ""
                    for j in xrange(len(keys)):
                        selement += table[j][i]
                    cstable.append(selement)
                signalList.append("    signal sdec : std_logic_vector(" + str(len(keys) - 1) + " downto 0);\n")
                signalList.append("    signal sdec_reg : std_logic_vector(" + str(len(keys) - 1) + " downto 0) := (others => '0');\n")
                ch_dec  = "    char_dec_rom: process(DATA)\n"
                ch_dec += "    begin\n"
                ch_dec += "        case DATA is\n"
                for i in xrange(256):
                    cval = bin(i)
                    cval = cval[2:]
                    cbin = "00000000"
                    cval = cbin[len(cval):] + cval
                    ch_dec += "            when \"" + cval + "\" => sdec <= \"" + cstable[i] + "\";\n"
                ch_dec += "            when others => sdec <= (others => '0');\n"
                ch_dec += "        end case;\n"
                ch_dec += "    end process char_dec_rom;\n\n"
                ch_dec += "    char_dec_rom_reg: process(CLK)\n"
                ch_dec += "    begin\n"
                ch_dec += "        if CLK'event and CLK='1' then\n"
                ch_dec += "            sdec_reg <= sdec;\n"
                ch_dec += "        end if;\n"
                ch_dec += "    end process char_dec_rom_reg;\n\n"
                descriptionList.append(ch_dec)
                for i in xrange(len(keys)):
                    signalList.append("    signal symbol_" + str(keys[i]) + " : std_logic;\n")
                    descriptionList.append("    symbol_" + str(keys[i]) + " <= sdec_reg(" + str(i) + ");\n")
                self._brams = int(math.ceil(float(len(keys)) / 36))
                return (signalList, descriptionList)
            # Character decoder implemented in LUTs
            else:
                # Set of all used characters - used to create the shared
                # character decoders
                allChars = set()
                
                # populate the allChars set
                for symbol in self._automaton.alphabet.keys():
                    # Add all chars from char class symbol
                    if self._automaton.alphabet[symbol].get_type() == b_symbol.io_mapper["b_Sym_char_class"]:
                        if len(self._automaton.alphabet[symbol].charClass) < 256:
                            if len(self._automaton.alphabet[symbol].charClass) <= 128:
                                for char in self._automaton.alphabet[symbol].charClass:
                                    allChars.add(char)
                            else:
                                for i in xrange(256):
                                    if chr(i) not in self._automaton.alphabet[symbol].charClass:
                                        allChars.add(chr(i))
                    # Add char from char symbol
                    if self._automaton.alphabet[symbol].get_type() == b_symbol.io_mapper["b_Sym_char"]:
                        allChars.add(self._automaton.alphabet[symbol].char)
                
                # List of signal definitions
                signalList = list()
                # list of logic description - architecture
                descriptionList = list()
                
                # Crate char decoder VHDL description for all used characters
                # Instantiates the VALUE_DECODER module.
                for char in allChars:
                    # Add signal definition into signalList
                    signalList.append("    signal char_" + str(ord(char)) + " : std_logic;\n")
                    # Create VHDL code
                    chrDec  = "    VD_" + str(ord(char)) + ": entity work.VALUE_DECODER\n" 
                    chrDec += "    generic map(\n"
                    chrDec += "        DATA_WIDTH => " + str(self.width) + ",\n"
                    chrDec += "        VALUE      => " + str(ord(char)) + "\n"
                    chrDec += "    )\n"
                    chrDec += "    port map(\n"
                    chrDec += "        INPUT  => DATA,\n"
                    chrDec += "        OUTPUT => char_" + str(ord(char)) + "\n"
                    chrDec += "    );\n\n"
                    # Add generated code to descriptionList - architecture
                    descriptionList.append(chrDec)
                    # Update number of used LUTs
                    self._luts += self._countLUTsForInpunts(self.width)
                
                # Create interconection and optionaly char classes
                for symbol in self._automaton.alphabet.keys():
                    # Create interconection
                    # Create shared char classes if char class symbols are used 
                    signalList.append("    signal symbol_" + str(symbol) + " : std_logic;\n")
                    if self._automaton.alphabet[symbol].get_type() == b_symbol.io_mapper["b_Sym_char_class"]:
                        if len(self._automaton.alphabet[symbol].charClass) < 256:
                            if len(self._automaton.alphabet[symbol].charClass) <= 128:
                                prefix = ""
                                suffix = ""
                            else:
                                prefix = "not ( "
                                suffix = ")"
                            text = "    symbol_" + str(symbol) + " <= " + prefix
                            first = True
                            
                            if len(self._automaton.alphabet[symbol].charClass) <= 128:
                                # Update number of used LUTs
                                self._luts += self._countLUTsForInpunts(len(self._automaton.alphabet[symbol].charClass))
                                for char in self._automaton.alphabet[symbol].charClass:
                                    if first == True:
                                        text += "char_" + str(ord(char))
                                        first = False
                                    else:
                                        text += " or char_" + str(ord(char))
                            else:
                                cnt_inp = 0
                                for i in xrange(256):
                                    if chr(i) not in self._automaton.alphabet[symbol].charClass:
                                        cnt_inp += 1
                                        if first == True:
                                            text += "char_" + str(i)
                                            first = False
                                        else:
                                            text += " or char_" + str(i)
                                # Update number of used LUTs
                                self._luts += self._countLUTsForInpunts(cnt_inp)
                            text += suffix + ";\n"
                            descriptionList.append(text)
                        else:
                            text = "    symbol_" + str(symbol) + " <= '1';\n"
                            descriptionList.append(text)
                    # Create interconection for char symbols
                    if self._automaton.alphabet[symbol].get_type() == b_symbol.io_mapper["b_Sym_char"]:
                        descriptionList.append("    symbol_" + str(symbol) + " <= char_" + str(ord(self._automaton.alphabet[symbol].char)) + ";\n")
                # Return generated signal and description list 
                return (signalList, descriptionList)
        # Shared character decoders for strided automaton
        else:
             # TODO: implement it in BRAM
            if self._useBram == True:
                # Compute BRAM ROM table
                table = [[["0" for x in xrange(256)] for y in xrange(len(self._automaton.alphabet))] for z in xrange(self._automaton.Flags["Stride"])]
                keys = self._automaton.alphabet.keys()
                for i in xrange(len(keys)):
                    for j in xrange(0, self._automaton.Flags["Stride"]):
                        if isinstance(self._automaton.alphabet[keys[i]].kchar[j], frozenset):
                            for char in self._automaton.alphabet[keys[i]].kchar[j]:
                                table[j][i][ord(char)] = "1"
                        else:
                            table[j][i][ord(self._automaton.alphabet[keys[i]].kchar[j])] = "1"
                # Generate BRAM ROM table VHDL code
                self._brams = 0
                # List of signal definitions
                signalList = list()
                # list of logic description - architecture
                descriptionList = list()
                for k in xrange(0, self._automaton.Flags["Stride"]):
                    cstable = list()
                    for i in xrange(256):
                        selement = ""
                        for j in xrange(len(keys)):
                            selement += table[k][j][i]
                        cstable.append(selement)
                    signalList.append("    signal sdec_" + str(k) + " : std_logic_vector(" + str(len(keys) - 1) + " downto 0);\n")
                    signalList.append("    signal sdec_reg_" + str(k) + " : std_logic_vector(" + str(len(keys) - 1) + " downto 0) := (others => '0');\n")
                    ch_dec  = "    char_dec_rom_" + str(k) + ": process(DATA)\n"
                    ch_dec += "    begin\n"
                    ch_dec += "        case DATA(" + str((k + 1) * 8 - 1)  + " downto " + str(k*8) + ") is\n"
                    for i in xrange(256):
                        cval = bin(i)
                        cval = cval[2:]
                        cbin = "00000000"
                        cval = cbin[len(cval):] + cval
                        ch_dec += "            when \"" + cval + "\" => sdec_" + str(k) + " <= \"" + cstable[i] + "\";\n"
                    ch_dec += "            when others => sdec_" + str(k) + " <= (others => '0');\n"
                    ch_dec += "        end case;\n"
                    ch_dec += "    end process char_dec_rom_" + str(k) + ";\n\n"
                    ch_dec += "    char_dec_rom_reg_" + str(k) + ": process(CLK)\n"
                    ch_dec += "    begin\n"
                    ch_dec += "        if CLK'event and CLK='1' then\n"
                    ch_dec += "            sdec_reg_" + str(k) + " <= sdec_" + str(k) + ";\n"
                    ch_dec += "        end if;\n"
                    ch_dec += "    end process char_dec_rom_reg_" + str(k) + ";\n\n"
                    descriptionList.append(ch_dec)
                    for i in xrange(len(keys)):
                        signalList.append("    signal symbol_" + str(keys[i]) + "_" + str(k) + " : std_logic;\n")
                        descriptionList.append("    symbol_" + str(keys[i]) + "_" + str(k) + " <= sdec_reg_" + str(k) + "(" + str(i) + ");\n")
                    self._brams += int(math.ceil(float(len(keys)) / 36))
                for symbol in self._automaton.alphabet.keys():
                    # Create signal definition for whole kchar
                    signalList.append("    signal symbol_" + str(symbol) + " : std_logic;\n")
                    #Create connection between subsymbols ans whole symbols
                    text = "    symbol_" + str(symbol) + " <= "
                    first = True
                    # Update number of used LUTs
                    self._luts += self._countLUTsForInpunts(self._automaton.Flags["Stride"])
                    # Create 'and' code
                    for i in range(0, self._automaton.Flags["Stride"]):
                        if first == True:
                            text += "symbol_" + str(symbol) + "_" + str(i)
                            first = False
                        else:
                            text += " and symbol_" + str(symbol) + "_" + str(i)
                    text += ";\n"
                    # Update description list
                    descriptionList.append(text)
                # Return generated signal and description list 
                return (signalList, descriptionList)
            # Character decoder implemented in LUTs
            else:
                # List(Set) of all used characters for all strided symbols - 
                # used to create the shared character decoders for every 
                # character in stride
                allChars = list()
                # Init list with empty sets
                for i in range(0, self._automaton.Flags["Stride"]):
                    allChars.append(set())

                # populate the allChars list
                for symbol in self._automaton.alphabet.keys():
                    # Iterate over all chars in strided symbols
                    for i in range(0, self._automaton.Flags["Stride"]):
                        # Check if current char in stride is char class
                        if isinstance(self._automaton.alphabet[symbol].kchar[i], frozenset): 
                            if len(self._automaton.alphabet[symbol].kchar[i])<256:
                                if len(self._automaton.alphabet[symbol].kchar[i]) <= 128:
                                    # Add all chars from kchar symbols for current
                                    # char class in stride
                                    for char in self._automaton.alphabet[symbol].kchar[i]:
                                        allChars[i].add(char)
                                else:
                                    for j in xrange(256):
                                        if chr(j) not in self._automaton.alphabet[symbol].kchar[i]:
                                            allChars[i].add(chr(j))
                        #  Add char from kchar symbols for current char in stride
                        else:
                            allChars[i].add(self._automaton.alphabet[symbol].kchar[i])

                # List of signal definitions
                signalList = list()
                # list of logic description - architecture
                descriptionList = list()
                
                # Crate char decoder VHDL descriptions for all used 
                # subcharacters
                for i in range(0, self._automaton.Flags["Stride"]):
                    # Crate char decoder VHDL description for all used 
                    # subcharacters in current part of strided symbol.
                    # Instantiates the VALUE_DECODER module.
                    for char in allChars[i]:
                        signalList.append("    signal char_" + str(ord(char)) + "_" + str(i) + " : std_logic;\n")
                        chrDec  = "    VD_" + str(ord(char)) + "_" + str(i) + ": entity work.VALUE_DECODER\n" 
                        chrDec += "    generic map(\n"
                        chrDec += "        DATA_WIDTH => " + "8" + ",\n"
                        chrDec += "        VALUE      => " + str(ord(char)) + "\n"
                        chrDec += "    )\n"
                        chrDec += "    port map(\n"
                        chrDec += "        INPUT  => DATA(" + str((i + 1) * 8 - 1)  + " downto " + str(i*8) + "),\n"
                        chrDec += "        OUTPUT => char_" + str(ord(char)) + "_" + str(i) + "\n"
                        chrDec += "    );\n\n"
                        descriptionList.append(chrDec)
                        # Update number of used LUTs
                        self._luts += self._countLUTsForInpunts(8) 
                
                # Create list of char classes for all subchars of kchar
                allCharClasses = list()
                # Dict of char classes
                classDict      = list()
                # Init those structures
                for i in range(0, self._automaton.Flags["Stride"]):
                    allCharClasses.append(set())
                    classDict.append(dict())
                    
                # Populate allCharClasses list
                for symbol in self._automaton.alphabet.keys():
                    for i in range(0, self._automaton.Flags["Stride"]):
                        if isinstance(self._automaton.alphabet[symbol].kchar[i], frozenset):
                            if len(self._automaton.alphabet[symbol].kchar[i])<256:
                                if len(self._automaton.alphabet[symbol].kchar[i]) <= 128:
                                    allCharClasses[i].add(self._automaton.alphabet[symbol].kchar[i])
                                else:
                                    CharClass = set()
                                    for j in xrange(256):
                                        if chr(j) not in self._automaton.alphabet[symbol].kchar[i]:
                                            CharClass.add(chr(j))
                                    allCharClasses[i].add(frozenset(CharClass))
                
                # For all subsymbols create interconection
                # Create shared char classes
                for i in range(0, self._automaton.Flags["Stride"]):           
                    index = 0
                    for cls in allCharClasses[i]:
                        # Update index of current char class
                        classDict[i][cls] = index
                        # Create signal definition
                        signalList.append("    signal class_" + str(index) + "_" + str(i) + " : std_logic;\n")
                        # Create code start for current char class
                        text = "    class_" + str(index) + "_" + str(i) + " <= "
                        first = True
                        
                        # Create code
                        for char in cls:
                            if first == True:
                                text += "char_" + str(ord(char)) + "_" + str(i)
                                first = False
                            else:
                                text += " or char_" + str(ord(char)) + "_" + str(i)
                        # Update number of used LUTs
                        self._luts += self._countLUTsForInpunts(len(cls))
                        text += ";\n"
                        # Add to description list - architecture
                        descriptionList.append(text)
                        # Update current class index by 1
                        index += 1
                
                # Create interconection between subsymbols and whole kchars
                for symbol in self._automaton.alphabet.keys():
                    # Create signal definition for whole kchar
                    signalList.append("    signal symbol_" + str(symbol) + " : std_logic;\n")
                    # Craete definitions and descriptions for subsymbols
                    for i in range(0, self._automaton.Flags["Stride"]):
                        # Create signal definition for subsymbol
                        signalList.append("    signal symbol_" + str(symbol) + "_" + str(i) + " : std_logic;\n")
                        
                        # If subsymbol is char class cretate interconection to 
                        # this charclass
                        if isinstance(self._automaton.alphabet[symbol].kchar[i], frozenset):
                            if len(self._automaton.alphabet[symbol].kchar[i]) < 256:
                                if len(self._automaton.alphabet[symbol].kchar[i]) <= 128:
                                    descriptionList.append("    symbol_" + str(symbol) + "_" + str(i) + " <= class_" + str(classDict[i][self._automaton.alphabet[symbol].kchar[i]]) + "_" + str(i) + ";\n")
                                else:
                                    CharClass = set()
                                    for j in xrange(256):
                                        if chr(j) not in self._automaton.alphabet[symbol].kchar[i]:
                                            CharClass.add(chr(j))
                                    descriptionList.append("    symbol_" + str(symbol) + "_" + str(i) + " <= not(class_" + str(classDict[i][frozenset(CharClass)]) + "_" + str(i) + ");\n")
                            else:
                                descriptionList.append("    symbol_" + str(symbol) + "_" + str(i) + " <= '1';\n")
                                
                        # Otherwise conect to shared char decoder directly
                        else:
                            descriptionList.append("    symbol_" + str(symbol) + "_" + str(i) + " <= char_" + str(ord(self._automaton.alphabet[symbol].kchar[i])) + "_" + str(i) + ";\n")
                    # Create interconection between subsymbols and whole kchars
                    # - description part
                    text = "    symbol_" + str(symbol) + " <= "
                    first = True
                    # Update number of used LUTs
                    self._luts += self._countLUTsForInpunts(self._automaton.Flags["Stride"])
                    # Create 'and' code
                    for i in range(0, self._automaton.Flags["Stride"]):
                        #if isinstance(self._automaton.alphabet[symbol].kchar[i], frozenset) and len(self._automaton.alphabet[symbol].kchar[i]) == 256:
                            #continue
                        if first == True:
                            text += "symbol_" + str(symbol) + "_" + str(i)
                            first = False
                        else:
                            text += " and symbol_" + str(symbol) + "_" + str(i)
                    text += ";\n"
                    # Update description list
                    descriptionList.append(text)
                    
                # Return generated signal and description list 
                return (signalList, descriptionList)
                
    def _get_logic_HDL(self):
        """ 
            Return HDL description of states and transitions as                \
            (signals, description). 
            
            :returns: HDL description of states and transitions as             \
                     (signals, description).
            :rtype: tuple(list(string),list(string)) 
        """
        # List of signal definitions
        signalList = list()
        # list of logic description - architecture
        descriptionList = list()
        
        # For all states generate states modules
        for state in self._automaton.states.keys():
            # Define signals for current state
            signalList.append("    signal state_in_" + str(state) + " : std_logic;\n")
            signalList.append("    signal state_out_" + str(state) + " : std_logic;\n")
            
            # If state is start state of automaton, set generic DEFAULT to '1'
            if state == self._automaton.start:
                text  =  "    STATE_" + str(state) + ": entity work.STATE\n"
                text +=  "    generic map(\n"
                text +=  "        DEFAULT     => '1'\n"
                text +=  "    )\n"
                text +=  "    port map(\n"
                text +=  "        CLK    => CLK,\n"
                text +=  "        RESET  => local_reset,\n"
                text +=  "        INPUT  => '0',\n"
                text +=  "        WE     => we,\n"
                text +=  "        OUTPUT => state_out_" + str(state) + "\n"
                text +=  "    );\n\n"
            # Otherwise set generic DEFAULT to '0' for any other state
            else:
                text  =  "    STATE_" + str(state) + ": entity work.STATE\n"
                text +=  "    generic map(\n"
                text +=  "        DEFAULT     => '0'\n" 
                text +=  "    )\n"
                text +=  "    port map(\n"
                text +=  "        CLK    => CLK,\n"
                text +=  "        RESET  => local_reset,\n"
                text +=  "        INPUT  => state_in_" + str(state) + ",\n"
                text +=  "        WE     => we,\n"
                text +=  "        OUTPUT => state_out_" + str(state) + "\n"
                text +=  "    );\n\n"
            # Add generated state module instantiation to corespondig
            # description list
            descriptionList.append(text)
        
        # Compute for all states their input transitions
        inputTransitions = dict()
        for transition in self._automaton.transitions:
            if inputTransitions.has_key(transition[2]) == True:
                inputTransitions[transition[2]].add((transition[0], transition[1]))
            else:
                inputTransitions[transition[2]] = set()
                inputTransitions[transition[2]].add((transition[0], transition[1]))
        
        # Generate interconection between states and between character decoders
        # and states
        for state in inputTransitions.keys():
            # If only 1 input transition is present just add previous state 
            # output and character decoder output
            if len(inputTransitions[state]) == 1:
                self._luts += self._countLUTsForInpunts(self._get_optimised_inputs(inputTransitions[state]))
                data = inputTransitions[state].pop()
                # Add code to decription list
                descriptionList.append("    state_in_" + str(state) + " <= state_out_" + str(data[0]) + " and symbol_" + str(data[1]) + ";\n")
                # Update number of used LUTs
                #self._luts += self._countLUTsForInpunts(2)
            # For more input transitions create coresponding conection structure
            # (OUTPUT AND CHAR) or (OUTPUT AND CHAR) or (OUTPUT AND CHAR) or ...
            else:
                text = str()
                first = True
                # Update number of used LUTs
                #self._luts += self._countLUTsForInpunts(2*len(inputTransitions[state]))
                self._luts += self._countLUTsForInpunts(self._get_optimised_inputs(inputTransitions[state]))
                # Generate VHDL code
                for transition in inputTransitions[state]:
                    if first == True:
                        text += "    state_in_" + str(state) + " <= (state_out_" + str(transition[0]) + " and symbol_" + str(transition[1]) + ")"
                        first = False
                    else:
                        text += " or (state_out_" + str(transition[0]) + " and symbol_" + str(transition[1]) + ")"
                text += ";\n"
                # Add code to decription list
                descriptionList.append(text)
        # Return generated signal and description list 
        return (signalList, descriptionList)

    def _get_optimised_inputs(self, trans):
        """
            Get optimal count of inputs for counting LUTs. Code generator is   \
            not optimised yet as we hope that synthetiser can optimise this    \
            trivial logic.
            
            :param trans: Input transitions for target state
            :type trans: set(list(int, int))
            
            :returns: Count of inputs of logical function tree
            :rtype: int
        """
        t_dict = dict()
        for transition in trans:
            if t_dict.has_key(transition[1]) == False:
                t_dict[transition[1]] = set()
            t_dict[transition[1]].add(transition[0])
        count = 0
        for symbol in t_dict:
            if self.stride == 1:
                if self._automaton.alphabet[symbol].get_type() == b_symbol.io_mapper["b_Sym_char_class"]:
                    if len(self._automaton.alphabet[symbol].charClass) < 256:
                        count += 1 + len(t_dict[symbol])
                    else:
                        count += len(t_dict[symbol])
            else:
                all_ones = True
                for part in self._automaton.alphabet[symbol].kchar:
                    if isinstance(part, frozenset):
                        if len(part) < 256:
                            all_ones = False
                    else:
                        all_ones = False
                if all_ones == True:
                    count += len(t_dict[symbol])
                else:
                    count += 1 + len(t_dict[symbol])
        return count

    def _get_final_HDL(self):
        """ 
            Return HDL description of interconection of final states as        \
            (signals, description). 
            
            :returns: HDL description of interconection of final states as     \
                      (signals, description).
            :rtype: tuple(list(string),list(string))
        """
        # List of signal definitions
        signalList = list()
        # list of logic description - architecture
        descriptionList = list()
        
        # Conect final states with their RE numbers
        sameFinal = dict()
        for fstate in self._automaton.final:
            rnums = self._automaton.states[fstate].get_regexp_number()
            for rnum in rnums:
                if sameFinal.has_key(rnum) == True:
                    sameFinal[rnum].add(fstate)
                else:
                    sameFinal[rnum] = set()
                    sameFinal[rnum].add(fstate)
        
        # Set number of final states to number of RE
        self._fStateNum = len(sameFinal)
        
        # Create input signal for final_bitmap module
        signalList.append("    signal bitmap_in : std_logic_vector(" + str(len(sameFinal)) + " - 1 downto 0);\n")
        
        # Create interconection between final states and final_bitmap module
        # inputs - creates 1 bit signals
        for final in sameFinal.keys():
            signalList.append("    signal final_" + str(final) + " : std_logic;\n")
            # If number of final states coresponding to same RE is 1, just 
            # connect them
            if len(sameFinal[final]) == 1:
                state = sameFinal[final].pop()
                # Add code to decription list
                descriptionList.append("    final_" + str(final) + " <= state_out_" + str(state) + ";\n")
            # If number of final states coresponding to same RE higher than 1, 
            # 'or' final states outputs
            else:
                first = True
                # Update number of used LUTs
                self._luts += self._countLUTsForInpunts(len(sameFinal[final]))
                # Compute 'or' code structure
                for pfinal in sameFinal[final]:
                    if first == True:
                        text = "    final_" + str(final) + " <= state_out_" + str(pfinal)
                        first = False
                    else:
                        text += " or state_out_" + str(pfinal)
                text += ";\n"
                # Add code to decription list
                descriptionList.append(text)
        
        # Conect 1 bit signals into input vector of final_bitmap module
        sfKeys = sameFinal.keys()
        for i in range(0, len(sfKeys)):
            # Add code to decription list
            descriptionList.append("    bitmap_in(" + str(i) + ") <= final_" + str(sfKeys[i]) + ";\n")

        # Return generated signal and description list 
        return (signalList, descriptionList)

    def report_logic(self):
        """ 
            Reports amount of logic consumed by the algorithm. 
            
            :returns: Amount of logic consumed by the algorithm                \
                      (LUTs, FlipFlops, BRAMs).
            :rtype: tuple(int, int, int)
        """
        # If number of LUTs is equal to zero call get_HDL() method to perform 
        # the mapping and to compute number of used LUTs
        if self._luts == 0:
            self.get_HDL()
        
        # Number of used FFs is equivalent to number of states and size of 
        # final_bitmap unit.
        ffSize = len(self._automaton.states) + self._fStateNum + 1
        
        # In current implementation BRAM size is always 0
        if self._useBram == False:
            bramSize = 0
        else:
            bramSize = self._brams
        
        # Return computed resource consumption
        return (self._luts, ffSize, bramSize)
        
    def _countLUTsForInpunts(self, inputs, is_not = False):
        """
            Counts amount of LUTs necessary for implenentation of inputs-input \
            logic function. This creates simple tree structure of n-input LUTs \
            for inputs-input logical function with 1 output. This method only  \
            gives upper bound of actual implementation by synthesis tool.
            
            :param inputs: Number of logic function inputs
            :type inputs: int
            
            :param is_not: Is operation not
            :type is_not: boolean
            
            :returns: Amount of LUTs necessary for implenentation of           \
                      inputs-input logic function.
            :rtype: int
        """
        # Set start values
        i = inputs
        res = 0;
        if i == 1 and is_not == False:
            return 0
        # Number of inputs is lower than number of LUT inputs, just return 1
        if i <= self._LUTInputs:
            res = 1;
        # Else compute simple tree implementation
        else:
            # While number of current level inputs is bigger than number of LUT
            # inputs create new layer of luts
            while i > self._LUTInputs:
                # Perform eventual rounds for border LUTs of current level
                if i/self._LUTInputs == round(i/self._LUTInputs):
                    res = res + int(round((i / self._LUTInputs), 0))
                    i = int(round((i / self._LUTInputs), 0))
                else:
                    res = res + int(round((i / self._LUTInputs) + 0.5, 0))
                    i = int(round((i / self._LUTInputs) + 0.5, 0))
            # Add final level LUT
            res = res + 1;
        
        # Return number of LUTs
        return res
