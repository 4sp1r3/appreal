from b_hash import b_hash
from b_hash import NoData
from jenkins import jenkins
from h3_hash import h3_hash
from jenkins import jenkins_fast, jenkins_wrapper
from graph import *
from collections import deque
from bitstring import BitArray
import math


class bdz(b_hash):
    """Class for perfect hash function generated by the BDZ algorithm. This algorithms uses uniform random hypergraph."""
    def __init__(self):
        b_hash.__init__(self)
        self.known_keys = False   #Keyset is not set
        self.function_number = 3  #random 3-graph
        self.iteration_limit = 5 
        self.ratio = 1.24         #ratio between keyset size and theconsumed memory
        self.limit = -1
        self.m = -1
        self.g = None;

    def get_g(self):
        """This function return values of the g array. It can not be called before the generate_seed, since it is part of the seed"""
        return self.g

    def get_range(self):
        """This function returns the size of the biggest possible hash value. If the range is not known yet, the -1 is returned"""
        return self.m

    def get_ratio(self):
        """Return ratio c between keyset and the size of the memory"""
        return self.ratio

    def set_ratio(self,ratio):
        """sets the ration and therefore size of the data structure of the PHF"""
        self.ratio = ratio

    def set_limit(self, limit):
        """Sets the size of the memory bank for one hash function. This function can be used instead of the set ratio. BDZ computes three hash functions with nonoverlapping outputs. Outputs of these hash functions are used as a pointers to the memory. If user know amount of the memory, he may set the limit as 1/3 of the available memory. The ration and other parameters are computed when the key set is given. The limit value always take precedents before the ratio. To stop using limit value, limit should be set to the negative value."""
        self.limit = limit;

    def get_iteration_limit(self):
        """The BDZ algorithm may have fail to create PHF. The iteration_limit is used to limit the number of attempts of PHF creation"""
        return self.iteration_limit

    def set_iteration_limit(self,iteration_limit):
        """The BDZ algorithm may have fail to create PHF. The iteration_limit is used to limit the number of attempts of PHF creation"""
        self.iteration_limit = iteration_limit

    def get_order(self):
        """This function return the number of uniform hash function used to create hypergraph"""
        return self.function_number

    def set_order(self,number):
        """This function sets the number of hash function used for the creation of the hypergraph. It can not be changed after generation of the PHF"""
        self.function_number = number

    def set_keys(self, key_set):
        """This is a perfect hash function. For the construction of the PHF, the set of keys has to be known. This function gives set of keys to the function, so generate_seed can build correct function"""
        self.key_set = key_set
        self.known_keys = True
        if self.limit > 0 :
            #The limit is set, recompute ratio for the given limit
            self.ratio = (3.0*self.limit)/len(key_set)

    def is_key_set(self):
        """This function return information, if the set of keys is prepared for the generation of the PHF"""
        return self.known_keys

    def _found_graph(self):
        """This is internal function. It generate random hypergraph according to the specification in the bdz class. It returns a queue of the edge and changes internal datastructure of BDZ class. Returned edges are ordered in such way, that they can be used for the construction of the PHF"""
        #First step is to initialize seed
        self.seed = dict()
        #Second step is to generate the random hash functions
        hashes = list()
        for i in range(0,self.function_number):
            x = jenkins_wrapper()
            x.generate_seed()
        #    x = h3_hash()
        #    x.set_bitsize(16)
        #    x.set_input_size(len(self.key_set[0]))
        #    x.generate_seed()
            hashes.append(x)
        self.seed["hashes"] = hashes
        #setting m
        self.m = int(math.ceil(self.ratio * len(self.key_set)))
        limit = int(math.ceil(float(self.m) /self.function_number))
        self.m = 3*limit
        #print("XXXXXXXXXXXXXXX",limit, self.m)
        #Generation of hypergraph
        hyper = graph()
        hyper.set_order(self.function_number)
        hyper.add_vertices(self.m)
        #Generation of the edges of the hypergraph
        for x in self.key_set:
            values = list()
            for i in self.seed["hashes"]:
                #print("test",i.hash(x)%limit,limit*len(values))
                vertex = (i.hash(x) % limit) + limit*len(values)
                values.append(vertex)
            #Add this edge into the hypergraph
            e = hyper.add_edge(values)
           # print(e.get_vertices())
            #Add edge to the vertices
            for v in values:
                hyper.get_vertex(v).add_edge(e)
        #Generate queue for the edge evaluation
        queue_list = []
        queue = deque()
        #Boolean vector of the used edges
        used = [False] * hyper.get_edge_number()
        #First remove edges that have at least one vertex with degree 1 
        for i in range(0,hyper.get_edge_number()):
            vert = hyper.get_edge(i).get_vertices()
            #print([hyper.get_vertex(x).get_degree() for x in vert])
            Deg = [hyper.get_vertex(x).get_degree() == 1 for x in vert]
            if sum(Deg) > 0 and used[i] == False:
               #This edge has at least one vertex with degree 1
               used[i] = True
               queue_list.append(i)
               queue.append(i) 
        #Removing edges that have unique vertex (on the stack)
        #adding a new edges with unique vertex into stack
        while(len(queue)>0):
            edge = queue.popleft()
            #remove edge from the graph (only from vertex and decrease degree)
            for v in hyper.get_edge(edge).get_vertices():
                hyper.get_vertex(v).get_edges().remove(hyper.get_edge(edge))
                deg = hyper.get_vertex(v).get_degree() - 1
                #print("KVIK",deg)
                hyper.get_vertex(v).set_degree(deg)
                #if degree decrease to 1, the remaining edge should be added 
                #into the queue
                if(deg == 1):
                    #Found the edge position
                    e1 = hyper.get_vertex(v).get_edges()[0]
                    position = hyper.get_edge_position(e1)
                    #If it is not in the queue, put it there
                    if used[position] == False:
                        queue.append(position)
                        queue_list.append(position)
                        used[position] = True 
        self.hyper = hyper
        return queue_list

    def _found_g(self,v,ed,vi):
        """This function computes value of the g array for given vertex. It uses plus operation."""
        s = [self.g[s1] for s1 in self.hyper.get_edge(ed).get_vertices()]
        sum1 = sum(s)-s[vi];
        self.g[v] = (vi-sum1)%len(s)
        return True;

    def _found_g2(self,v,ed,vi):
        """This function computes value of the g array for given vertex by the use of the xor function. Assumes two bit representation of the g array"""
        s = [self.g[s1] for s1 in self.hyper.get_edge(ed).get_vertices()]
        sum1 = s[0];
        for index in range(1,len(self.hyper.get_edge(ed).get_vertices())):
             sum1 = sum1^s[index]
        sum1 = sum1^s[vi]
        self.g[v] = (vi^sum1)&3   #3 is the 11 in binary, therefore it clear all the higher bits to zero
        return True 
        



    def generate_seed(self):
        """This function generates the PHF function according to the BDZ algorithm"""
        if not self.known_keys:
            raise NoData("The key set is unknown")
        size = 0
        iteration = 0
        while(size != len(self.key_set) and self.iteration_limit > iteration):
            queue = self._found_graph()
            size = len(queue)
            iteration = iteration+1
        if(len(queue) != len(self.key_set)):
            return False
        self.g = [3] * self.m
        marked_vertices = [False] *self.m
        while(len(queue) > 0):
            ed = queue.pop()
            worked = False 
            for vi in range(0,len(self.hyper.get_edge(ed).get_vertices())):
               v = self.hyper.get_edge(ed).get_vertices()[vi]
               if(marked_vertices[v] == False and worked == False):
                   worked = self._found_g2(v,ed,vi)
               marked_vertices[v] = True
               
       # print(self.g)
       # print(self.g)
       # print(len(queue))
       # print(len(self.key_set))
            
    def hash(self, key):
       limit = int(self.m /self.function_number)
      # print(limit)
       hashes = [x.hash(key)%limit for x in self.seed["hashes"]]
       h1 = [hashes[x]+x*limit for x in range(0,len(hashes))]
       g_val = [self.g[x] for x in h1] 
       sum1 = g_val[0];
       for index in range(1,len(g_val)):
            sum1 = sum1^g_val[index]
       h = sum1&3
       if h>=len(hashes):
           h = 0
           return -1
#           print("Nonexistent key")
       #print(hashes,g_val)
       #h  = sum(g_val)%len(g_val)
       return hashes[h]+(limit*h)
